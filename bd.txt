-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS auth.audit_log_entries
(
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT ''::character varying,
    CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.audit_log_entries
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.audit_log_entries
    IS 'Auth: Audit trail for user actions.';

CREATE TABLE IF NOT EXISTS auth.flow_state
(
    id uuid NOT NULL,
    user_id uuid,
    auth_code text COLLATE pg_catalog."default" NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text COLLATE pg_catalog."default" NOT NULL,
    provider_type text COLLATE pg_catalog."default" NOT NULL,
    provider_access_token text COLLATE pg_catalog."default",
    provider_refresh_token text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text COLLATE pg_catalog."default" NOT NULL,
    auth_code_issued_at timestamp with time zone,
    CONSTRAINT flow_state_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.flow_state
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.flow_state
    IS 'stores metadata for pkce logins';

CREATE TABLE IF NOT EXISTS auth.identities
(
    provider_id text COLLATE pg_catalog."default" NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text COLLATE pg_catalog."default" NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text COLLATE pg_catalog."default" GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    CONSTRAINT identities_pkey PRIMARY KEY (id),
    CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider)
);

ALTER TABLE IF EXISTS auth.identities
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.identities
    IS 'Auth: Stores identities associated to a user.';

COMMENT ON COLUMN auth.identities.email
    IS 'Auth: Email is a generated column that references the optional email property in the identity_data';

CREATE TABLE IF NOT EXISTS auth.instances
(
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT instances_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.instances
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.instances
    IS 'Auth: Manages users across multiple sites.';

CREATE TABLE IF NOT EXISTS auth.mfa_amr_claims
(
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text COLLATE pg_catalog."default" NOT NULL,
    id uuid NOT NULL,
    CONSTRAINT amr_id_pk PRIMARY KEY (id),
    CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method)
);

ALTER TABLE IF EXISTS auth.mfa_amr_claims
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_amr_claims
    IS 'auth: stores authenticator method reference claims for multi factor authentication';

CREATE TABLE IF NOT EXISTS auth.mfa_challenges
(
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text COLLATE pg_catalog."default",
    web_authn_session_data jsonb,
    CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.mfa_challenges
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_challenges
    IS 'auth: stores metadata about challenge requests made';

CREATE TABLE IF NOT EXISTS auth.mfa_factors
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text COLLATE pg_catalog."default",
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text COLLATE pg_catalog."default",
    phone text COLLATE pg_catalog."default",
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid,
    CONSTRAINT mfa_factors_pkey PRIMARY KEY (id),
    CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at)
);

ALTER TABLE IF EXISTS auth.mfa_factors
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.mfa_factors
    IS 'auth: stores metadata about factors';

CREATE TABLE IF NOT EXISTS auth.one_time_tokens
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text COLLATE pg_catalog."default" NOT NULL,
    relates_to text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.one_time_tokens
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS auth.refresh_tokens
(
    instance_id uuid,
    id bigserial NOT NULL,
    token character varying(255) COLLATE pg_catalog."default",
    user_id character varying(255) COLLATE pg_catalog."default",
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255) COLLATE pg_catalog."default",
    session_id uuid,
    CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id),
    CONSTRAINT refresh_tokens_token_unique UNIQUE (token)
);

ALTER TABLE IF EXISTS auth.refresh_tokens
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.refresh_tokens
    IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';

CREATE TABLE IF NOT EXISTS auth.saml_providers
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text COLLATE pg_catalog."default" NOT NULL,
    metadata_xml text COLLATE pg_catalog."default" NOT NULL,
    metadata_url text COLLATE pg_catalog."default",
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text COLLATE pg_catalog."default",
    CONSTRAINT saml_providers_pkey PRIMARY KEY (id),
    CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id)
);

ALTER TABLE IF EXISTS auth.saml_providers
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.saml_providers
    IS 'Auth: Manages SAML Identity Provider connections.';

CREATE TABLE IF NOT EXISTS auth.saml_relay_states
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text COLLATE pg_catalog."default" NOT NULL,
    for_email text COLLATE pg_catalog."default",
    redirect_to text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.saml_relay_states
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.saml_relay_states
    IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';

CREATE TABLE IF NOT EXISTS auth.schema_migrations
(
    version character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);

ALTER TABLE IF EXISTS auth.schema_migrations
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.schema_migrations
    IS 'Auth: Manages updates to the auth system.';

CREATE TABLE IF NOT EXISTS auth.sessions
(
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text COLLATE pg_catalog."default",
    ip inet,
    tag text COLLATE pg_catalog."default",
    CONSTRAINT sessions_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sessions
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sessions
    IS 'Auth: Stores session data associated to a user.';

COMMENT ON COLUMN auth.sessions.not_after
    IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';

CREATE TABLE IF NOT EXISTS auth.sso_domains
(
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT sso_domains_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sso_domains
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sso_domains
    IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';

CREATE TABLE IF NOT EXISTS auth.sso_providers
(
    id uuid NOT NULL,
    resource_id text COLLATE pg_catalog."default",
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT sso_providers_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS auth.sso_providers
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.sso_providers
    IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';

COMMENT ON COLUMN auth.sso_providers.resource_id
    IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';

CREATE TABLE IF NOT EXISTS auth.users
(
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255) COLLATE pg_catalog."default",
    role character varying(255) COLLATE pg_catalog."default",
    email character varying(255) COLLATE pg_catalog."default",
    encrypted_password character varying(255) COLLATE pg_catalog."default",
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255) COLLATE pg_catalog."default",
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255) COLLATE pg_catalog."default",
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255) COLLATE pg_catalog."default",
    email_change character varying(255) COLLATE pg_catalog."default",
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text COLLATE pg_catalog."default" DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text COLLATE pg_catalog."default" DEFAULT ''::character varying,
    phone_change_token character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) COLLATE pg_catalog."default" DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean NOT NULL DEFAULT false,
    deleted_at timestamp with time zone,
    is_anonymous boolean NOT NULL DEFAULT false,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_phone_key UNIQUE (phone)
);

ALTER TABLE IF EXISTS auth.users
    ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE auth.users
    IS 'Auth: Stores user login data within a secure schema.';

COMMENT ON COLUMN auth.users.is_sso_user
    IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';

CREATE TABLE IF NOT EXISTS public.ar_internal_metadata
(
    key character varying COLLATE pg_catalog."default" NOT NULL,
    value character varying COLLATE pg_catalog."default",
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT ar_internal_metadata_pkey PRIMARY KEY (key)
);

CREATE TABLE IF NOT EXISTS public.curso_estudiantes
(
    id bigserial NOT NULL,
    curso_id bigint NOT NULL,
    usuario_id bigint NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT curso_estudiantes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.cursos
(
    id bigserial NOT NULL,
    nombre character varying COLLATE pg_catalog."default",
    descripcion text COLLATE pg_catalog."default",
    profesor_id bigint,
    categoria character varying COLLATE pg_catalog."default",
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    codigo character varying COLLATE pg_catalog."default",
    activo boolean DEFAULT true,
    periodo character varying COLLATE pg_catalog."default",
    estado integer,
    CONSTRAINT cursos_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.intentos_quiz
(
    id bigserial NOT NULL,
    quiz_id bigint NOT NULL,
    usuario_id bigint NOT NULL,
    estado integer DEFAULT 0,
    puntaje_total numeric(5, 2),
    iniciado_en timestamp(6) without time zone,
    finalizado_en timestamp(6) without time zone,
    tiempo_usado integer,
    numero_intento integer,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT intentos_quiz_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.laboratorios
(
    id bigserial NOT NULL,
    nombre character varying COLLATE pg_catalog."default",
    descripcion text COLLATE pg_catalog."default",
    curso_id bigint NOT NULL,
    tipo character varying COLLATE pg_catalog."default",
    estado character varying COLLATE pg_catalog."default",
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    nivel_dificultad character varying COLLATE pg_catalog."default",
    duracion_estimada integer,
    objetivos text COLLATE pg_catalog."default",
    requisitos text COLLATE pg_catalog."default",
    activo boolean DEFAULT true,
    CONSTRAINT laboratorios_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.metrica_laboratorios
(
    id bigserial NOT NULL,
    sesion_laboratorio_id bigint NOT NULL,
    cpu_usage double precision NOT NULL DEFAULT 0.0,
    memory_usage double precision NOT NULL DEFAULT 0.0,
    network_usage double precision NOT NULL DEFAULT 0.0,
    "timestamp" timestamp(6) without time zone NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT metrica_laboratorios_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.quiz_opciones
(
    id bigserial NOT NULL,
    pregunta_id bigint NOT NULL,
    contenido text COLLATE pg_catalog."default" NOT NULL,
    es_correcta boolean DEFAULT false,
    orden integer,
    activa boolean DEFAULT true,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT quiz_opciones_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.quiz_preguntas
(
    id bigserial NOT NULL,
    quiz_id bigint NOT NULL,
    contenido text COLLATE pg_catalog."default" NOT NULL,
    tipo integer NOT NULL,
    puntaje numeric(5, 2) NOT NULL,
    orden integer,
    activa boolean DEFAULT true,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT quiz_preguntas_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.quizzes
(
    id bigserial NOT NULL,
    titulo character varying COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default",
    curso_id bigint NOT NULL,
    laboratorio_id bigint NOT NULL,
    usuario_id bigint NOT NULL,
    estado integer DEFAULT 0,
    tiempo_limite integer,
    intentos_permitidos integer DEFAULT 1,
    activo boolean DEFAULT true,
    fecha_inicio timestamp(6) without time zone,
    fecha_fin timestamp(6) without time zone,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT quizzes_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.respuestas_quiz
(
    id bigserial NOT NULL,
    intento_quiz_id bigint NOT NULL,
    pregunta_id bigint NOT NULL,
    opcion_id bigint,
    respuesta_texto text COLLATE pg_catalog."default",
    puntaje_obtenido numeric(5, 2),
    es_correcta boolean,
    respondido_en timestamp(6) without time zone,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT respuestas_quiz_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.schema_migrations
(
    version character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);

CREATE TABLE IF NOT EXISTS public.sesion_laboratorios
(
    id bigserial NOT NULL,
    laboratorio_id bigint NOT NULL,
    usuario_id bigint NOT NULL,
    estado character varying COLLATE pg_catalog."default",
    tiempo_inicio timestamp(6) without time zone,
    tiempo_fin timestamp(6) without time zone,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    notas text COLLATE pg_catalog."default",
    resultados json,
    puntuacion integer,
    CONSTRAINT sesion_laboratorios_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.usuarios
(
    id bigserial NOT NULL,
    email character varying COLLATE pg_catalog."default" NOT NULL DEFAULT ''::character varying,
    encrypted_password character varying COLLATE pg_catalog."default" NOT NULL DEFAULT ''::character varying,
    reset_password_token character varying COLLATE pg_catalog."default",
    reset_password_sent_at timestamp(6) without time zone,
    remember_created_at timestamp(6) without time zone,
    nombre_completo character varying COLLATE pg_catalog."default",
    nombre_usuario character varying COLLATE pg_catalog."default",
    rol character varying COLLATE pg_catalog."default",
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT usuarios_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS realtime.messages
(
    topic text COLLATE pg_catalog."default" NOT NULL,
    extension text COLLATE pg_catalog."default" NOT NULL,
    payload jsonb,
    event text COLLATE pg_catalog."default",
    private boolean DEFAULT false,
    updated_at timestamp without time zone NOT NULL DEFAULT now(),
    inserted_at timestamp without time zone NOT NULL DEFAULT now(),
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at)
);

ALTER TABLE IF EXISTS realtime.messages
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS realtime.schema_migrations
(
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone,
    CONSTRAINT schema_migrations_pkey PRIMARY KEY (version)
);

CREATE TABLE IF NOT EXISTS realtime.subscription
(
    id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] NOT NULL DEFAULT '{}'::realtime.user_defined_filter[],
    claims jsonb NOT NULL,
    claims_role regrole NOT NULL GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED,
    created_at timestamp without time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    CONSTRAINT pk_subscription PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS storage.buckets
(
    id text COLLATE pg_catalog."default" NOT NULL,
    name text COLLATE pg_catalog."default" NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[] COLLATE pg_catalog."default",
    owner_id text COLLATE pg_catalog."default",
    CONSTRAINT buckets_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.buckets
    ENABLE ROW LEVEL SECURITY;

COMMENT ON COLUMN storage.buckets.owner
    IS 'Field is deprecated, use owner_id instead';

CREATE TABLE IF NOT EXISTS storage.migrations
(
    id integer NOT NULL,
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    hash character varying(40) COLLATE pg_catalog."default" NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT migrations_pkey PRIMARY KEY (id),
    CONSTRAINT migrations_name_key UNIQUE (name)
);

ALTER TABLE IF EXISTS storage.migrations
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS storage.objects
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    bucket_id text COLLATE pg_catalog."default",
    name text COLLATE pg_catalog."default",
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] COLLATE pg_catalog."default" GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text COLLATE pg_catalog."default",
    owner_id text COLLATE pg_catalog."default",
    user_metadata jsonb,
    CONSTRAINT objects_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.objects
    ENABLE ROW LEVEL SECURITY;

COMMENT ON COLUMN storage.objects.owner
    IS 'Field is deprecated, use owner_id instead';

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads
(
    id text COLLATE pg_catalog."default" NOT NULL,
    in_progress_size bigint NOT NULL DEFAULT 0,
    upload_signature text COLLATE pg_catalog."default" NOT NULL,
    bucket_id text COLLATE pg_catalog."default" NOT NULL,
    key text COLLATE pg_catalog."C" NOT NULL,
    version text COLLATE pg_catalog."default" NOT NULL,
    owner_id text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_metadata jsonb,
    CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.s3_multipart_uploads
    ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS storage.s3_multipart_uploads_parts
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    upload_id text COLLATE pg_catalog."default" NOT NULL,
    size bigint NOT NULL DEFAULT 0,
    part_number integer NOT NULL,
    bucket_id text COLLATE pg_catalog."default" NOT NULL,
    key text COLLATE pg_catalog."C" NOT NULL,
    etag text COLLATE pg_catalog."default" NOT NULL,
    owner_id text COLLATE pg_catalog."default",
    version text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id)
);

ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS identities_user_id_idx
    ON auth.identities(user_id);


ALTER TABLE IF EXISTS auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id)
    REFERENCES auth.sessions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id)
    REFERENCES auth.mfa_factors (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS mfa_factors_user_id_idx
    ON auth.mfa_factors(user_id);


ALTER TABLE IF EXISTS auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id)
    REFERENCES auth.sessions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS saml_providers_sso_provider_id_idx
    ON auth.saml_providers(sso_provider_id);


ALTER TABLE IF EXISTS auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id)
    REFERENCES auth.flow_state (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS saml_relay_states_sso_provider_id_idx
    ON auth.saml_relay_states(sso_provider_id);


ALTER TABLE IF EXISTS auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES auth.users (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS sessions_user_id_idx
    ON auth.sessions(user_id);


ALTER TABLE IF EXISTS auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id)
    REFERENCES auth.sso_providers (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS sso_domains_sso_provider_id_idx
    ON auth.sso_domains(sso_provider_id);


ALTER TABLE IF EXISTS public.curso_estudiantes
    ADD CONSTRAINT fk_rails_6ff2413979 FOREIGN KEY (usuario_id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_curso_estudiantes_on_usuario_id
    ON public.curso_estudiantes(usuario_id);


ALTER TABLE IF EXISTS public.curso_estudiantes
    ADD CONSTRAINT fk_rails_967f1d17be FOREIGN KEY (curso_id)
    REFERENCES public.cursos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_curso_estudiantes_on_curso_id
    ON public.curso_estudiantes(curso_id);


ALTER TABLE IF EXISTS public.cursos
    ADD CONSTRAINT fk_rails_7ee8126869 FOREIGN KEY (profesor_id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.intentos_quiz
    ADD CONSTRAINT fk_rails_109a36fd21 FOREIGN KEY (quiz_id)
    REFERENCES public.quizzes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_intentos_quiz_on_quiz_id
    ON public.intentos_quiz(quiz_id);


ALTER TABLE IF EXISTS public.intentos_quiz
    ADD CONSTRAINT fk_rails_e62c95978d FOREIGN KEY (usuario_id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_intentos_quiz_on_usuario_id
    ON public.intentos_quiz(usuario_id);


ALTER TABLE IF EXISTS public.laboratorios
    ADD CONSTRAINT fk_rails_c1046b9391 FOREIGN KEY (curso_id)
    REFERENCES public.cursos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_laboratorios_on_curso_id
    ON public.laboratorios(curso_id);


ALTER TABLE IF EXISTS public.metrica_laboratorios
    ADD CONSTRAINT fk_rails_4387890e9a FOREIGN KEY (sesion_laboratorio_id)
    REFERENCES public.sesion_laboratorios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_metrica_laboratorios_on_sesion_laboratorio_id
    ON public.metrica_laboratorios(sesion_laboratorio_id);


ALTER TABLE IF EXISTS public.quiz_opciones
    ADD CONSTRAINT fk_rails_e41ada43ab FOREIGN KEY (pregunta_id)
    REFERENCES public.quiz_preguntas (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_quiz_opciones_on_pregunta_id
    ON public.quiz_opciones(pregunta_id);


ALTER TABLE IF EXISTS public.quiz_preguntas
    ADD CONSTRAINT fk_rails_8db994b87a FOREIGN KEY (quiz_id)
    REFERENCES public.quizzes (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_quiz_preguntas_on_quiz_id
    ON public.quiz_preguntas(quiz_id);


ALTER TABLE IF EXISTS public.quizzes
    ADD CONSTRAINT fk_rails_72d0c6377c FOREIGN KEY (laboratorio_id)
    REFERENCES public.laboratorios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_quizzes_on_laboratorio_id
    ON public.quizzes(laboratorio_id);


ALTER TABLE IF EXISTS public.quizzes
    ADD CONSTRAINT fk_rails_dc7a51cc5d FOREIGN KEY (curso_id)
    REFERENCES public.cursos (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_quizzes_on_curso_id
    ON public.quizzes(curso_id);


ALTER TABLE IF EXISTS public.quizzes
    ADD CONSTRAINT fk_rails_fa55cb5f4d FOREIGN KEY (usuario_id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_quizzes_on_usuario_id
    ON public.quizzes(usuario_id);


ALTER TABLE IF EXISTS public.respuestas_quiz
    ADD CONSTRAINT fk_rails_37cffa939b FOREIGN KEY (intento_quiz_id)
    REFERENCES public.intentos_quiz (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_respuestas_quiz_on_intento_quiz_id
    ON public.respuestas_quiz(intento_quiz_id);


ALTER TABLE IF EXISTS public.respuestas_quiz
    ADD CONSTRAINT fk_rails_bf48b680ac FOREIGN KEY (pregunta_id)
    REFERENCES public.quiz_preguntas (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_respuestas_quiz_on_pregunta_id
    ON public.respuestas_quiz(pregunta_id);


ALTER TABLE IF EXISTS public.respuestas_quiz
    ADD CONSTRAINT fk_rails_dab1b29a9c FOREIGN KEY (opcion_id)
    REFERENCES public.quiz_opciones (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS index_respuestas_quiz_on_opcion_id
    ON public.respuestas_quiz(opcion_id);


ALTER TABLE IF EXISTS public.sesion_laboratorios
    ADD CONSTRAINT fk_rails_01455f0aa4 FOREIGN KEY (laboratorio_id)
    REFERENCES public.laboratorios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.sesion_laboratorios
    ADD CONSTRAINT fk_rails_b26229fdb8 FOREIGN KEY (usuario_id)
    REFERENCES public.usuarios (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id)
    REFERENCES storage.buckets (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id)
    REFERENCES storage.s3_multipart_uploads (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;

END;